[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "E155 Resources",
    "section": "",
    "text": "link to the course website here"
  },
  {
    "objectID": "Lab_1.html",
    "href": "Lab_1.html",
    "title": "FPGA Lab: High-Speed Oscillator LED Blinker",
    "section": "",
    "text": "Figure 1: Shows the Microprocessor Development Board v.4 with the Upduino FPGA and MCU, along with pushbuttons and switches.\nIn this lab, a design was implemented on the FPGA to demonstrate the functionality of the on-board high-speed oscillator by blinking one of the on-board LEDs on the development board (shown in Figure 1). The high-speed oscillator was configured at a frequency of 48 MHz and divided down using a counter to achieve a blinking frequency of 2.4 Hz."
  },
  {
    "objectID": "Lab_1.html#introduction",
    "href": "Lab_1.html#introduction",
    "title": "FPGA Lab: High-Speed Oscillator LED Blinker",
    "section": "",
    "text": "Figure 1: Shows the Microprocessor Development Board v.4 with the Upduino FPGA and MCU, along with pushbuttons and switches.\nIn this lab, a design was implemented on the FPGA to demonstrate the functionality of the on-board high-speed oscillator by blinking one of the on-board LEDs on the development board (shown in Figure 1). The high-speed oscillator was configured at a frequency of 48 MHz and divided down using a counter to achieve a blinking frequency of 2.4 Hz."
  },
  {
    "objectID": "Lab_1.html#design-and-testing-methodology",
    "href": "Lab_1.html#design-and-testing-methodology",
    "title": "FPGA Lab: High-Speed Oscillator LED Blinker",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nWe assembled the E155 development board by soldering SMT and THT components, followed by verifying voltage regulators (3.3V and 5V). Testing involved loading a pre-written FPGA design to blink LEDs and then programming the MCU to read and echo signals. Once verified, we wrote our own Verilog modules to interface DIP switches with LEDs and a 7-segment display, synthesizing the design in Lattice Radiant and simulating with Questa ModelSim. Git was used to track project source code files.\nThe on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library was used to generate a clock signal at 24 MHz. Then, a counter was used to divide the high-frequency clock signal down so that the blinking frequency could be easily visualized using one of the on-board LEDs."
  },
  {
    "objectID": "Lab_1.html#fpga-design",
    "href": "Lab_1.html#fpga-design",
    "title": "FPGA Lab: High-Speed Oscillator LED Blinker",
    "section": "FPGA Design",
    "text": "FPGA Design\nOn the E155 FPGA board, the inputs and outputs are organized around the switches, LEDs, and 7-segment display. The four DIP switches s[3:0] serve as user inputs, letting you select binary values that feed into the logic of the design. The three LEDs led[2:0] provide simple output indicators: led[0] and led[1] respond to combinations of the switch inputs, while led[2] blinks at a steady rate using the FPGA’s internal 48 MHz oscillator. Finally, the seven outputs seg[6:0] drive the segments of a common anode 7-segment display, which decodes the switch settings into a numeric pattern from to 0 to F.\n\n\n\nSignal Name\nType\nDetails\n\n\n\n\n[3:0] s\ninput\nDIP switches (SW6)\n\n\n[2:0] led\noutput\nLEDs (found on P42, P38, and P28)\n\n\n[6:0] seg\noutput\ncommon anode outputs on 7-segment display\n\n\n\nIn regards to the LEDs, led[2] blinks at a frequency of 2.4Hz while led[0] switches on based a XOR relationship with s[0] and s[1] and led[1] swithes on based on AND relationship with s[2] and s[3].\nHere is the following truth table:\n\n\n\n[3:0]s\n[2:0]led\n[6:0]seg\n\n\n\n\n0000\n000\n0000001\n\n\n0001\n001\n1001111\n\n\n0010\n001\n0010010\n\n\n0011\n000\n0000110\n\n\n0100\n000\n1001100\n\n\n0101\n001\n0100100\n\n\n0110\n001\n0100000\n\n\n0111\n000\n0001111\n\n\n1000\n000\n0000000\n\n\n1001\n001\n0001100\n\n\n1010\n001\n0001000\n\n\n1011\n000\n1100000\n\n\n1100\n010\n0110001\n\n\n1101\n011\n1000010\n\n\n1110\n011\n0110000\n\n\n1111\n010\n0111000\n\n\n\n\nTechnical Documentation\nThe source code for the project can be found in the associated GitHub repository.\n\n\nBlock Diagram\n\nFigure 2: Block diagram of the Verilog design.\nThe block diagram in Figure 1 demonstrates the overall architecture of the design. The top-level module lab1_bb includes two submodules: the high-speed oscillator block (HSOSC) and the 7 segement display sevenseg_dis.\n\n\nSchematic\n\nFigure 3: Schematic of the physical circuit of the FPGA, LEDs, switches and the 7-segment display.\n\nFigure 4: Show the internal wire from the FPGA to the 7-segment display.\nThis shows the physical layout of the design. An internal 1.5 kΩ pull-up resistor was used to ensure the active-low reset pin was not floating. The current running through the diode of the seven segment display (~1 mA) was divided by the Vcc subtracted by the forward voltage of a red LED."
  },
  {
    "objectID": "Lab_1.html#results-and-discussion",
    "href": "Lab_1.html#results-and-discussion",
    "title": "FPGA Lab: High-Speed Oscillator LED Blinker",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nThe design met all intended design objectives through our testbench simulations.\n\nTestbench Simulation\n Figure 5: Screenshot of a QuestaSim simulation demonstrating the blinking output signal.\nNote that the timescale for the clock divider was modified to divide by 4. If a more precise output frequency was desired, a more sophisticated counter could be developed. The current design only allows for the clock to be divided by powers of two. (MIGHT GET RID OF)\n\n\nOscilliscope of Blinking LED\n\nFigure 6: Screenshot of a oscilliscope waveform validating the exact frequency of 2.41 Hz."
  },
  {
    "objectID": "Lab_1.html#conclusion",
    "href": "Lab_1.html#conclusion",
    "title": "FPGA Lab: High-Speed Oscillator LED Blinker",
    "section": "Conclusion",
    "text": "Conclusion\nThe design successfully blinked an external LED using the on-board high-speed oscillator. I spent a total of 10+ hours working on this lab."
  },
  {
    "objectID": "Lab_1.html#ai-prototype-summary",
    "href": "Lab_1.html#ai-prototype-summary",
    "title": "FPGA Lab: High-Speed Oscillator LED Blinker",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nWhen conducting the AI prototype summary, the LLM I utilized was Microsoft’s Copilot. I prompted it to “Write SystemVerilog HDL to leverage the internal high-speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz, using idiomatic SystemVerilog. Copilot produced a short module that instantiated the UP5K high-speed oscillator, divided the clock with a counter, and drove an LED. The style was pretty clean for the counter. However, when I pasted it into a fresh Lattice Radiant project and hit Synthesize, Radiant failed immediately with a syntax error: Copilot had dropped a closing parenthesis in the oscillator instantiation and missed a semicolon at the end of a localparam line. After I copied Radiant’s error text back into Copilot, it regenerated the block with the missing ) and ; added. With those fixed, the synthesis was completed.\nI would rate Copilot’s output as “good scaffolding, needs verification.” It nailed the overall structure and used modern SystemVerilog constructs I like adopting. It also wrote a clear reset path for the counter. None of those were brand-new to me, but it was helpful to see them composed neatly in a minimal example. If I did this again, I would tighten my workflow in three ways:\n\nTreat the LLM as a code generator, not an authority. I’ll immediately run the output, then feed exact tool errors back to the model for focused corrections.\nAsk the LLM to “emit compile ready, tool-specific primitives” and include a checklist in the prompt. That nudge seems to reduce trivial mistakes.\nAdd a quick unit sanity check in the prompt: “Assume ~48 MHz HFOSC; show the counter width/math to reach ~2 Hz.” That forces the model to spell out the divide math, which is convenient to verify before synthesis."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Portfolio",
    "section": "",
    "text": "Hello! My name is Broderick Bownds and I am a junior engineering major with a focus of Electrical and Computer Engineering at Harvey Mudd College. I am passionate about designing efficient systems at the intersection of hardware and signal processing. My experience spans FPGA development, system-level design, CAD-based prototyping. Beyond the lab, I am committed to inclusive innovation, such as redesigning neuroimaging caps for textured hair, mentoring youth in 3D design and coding through Project Think, being involved in NSBE, and leading through the Annenberg Leadership Forum."
  },
  {
    "objectID": "Lab_2.html#introduction",
    "href": "Lab_2.html#introduction",
    "title": "Multiplexing Seven Segment Display",
    "section": "Introduction",
    "text": "Introduction\nIn this lab, a time-multiplexed display system was implemented using an FPGA Upduino Board to drive a dual seven-segment display with a single decoder module. The system displayed two independent hexadecimal values sourced from two DIP switches and showed their sum on five LEDs. The design utilized transistor-based current control such as PNP transistors to safely drive the common anodes of the displays, ensuring proper brightness and avoiding bleeding or ghosting."
  },
  {
    "objectID": "Lab_2.html#design-and-testing-methodology",
    "href": "Lab_2.html#design-and-testing-methodology",
    "title": "Multiplexing Seven Segment Display",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nThe design included the iCE FPGA’s high-speed osciallator (HSOSC) divided down by a counter to slow down the multiplexing clock. The slow clock toggles between enabling the left or right digit by activating its common anode transistor whiel routing the correspodnign 4-bit input (s0 or s1) into the seven segment decoder. If too fast or slow then there would be flickering or the two numbers would bleed together so we had the switching at 240Hz. Humans can perceive refresh rate at 60Hz so we can speed up the frequency by a factor of 4 it won’t look like the two displays are switching.\nThe outputs of the DIP swithes provided the two hexadecimal values (s0 and s1). These values are added and the (max number is 30, 5-bit wide) was displayed on five external LEDs. The seven segment require additonal transistor circuitry to handle the higher current of the common anode pins, since a FPGA pin cannot source the needed current (~8mA)."
  },
  {
    "objectID": "Lab_2.html#fpga-design",
    "href": "Lab_2.html#fpga-design",
    "title": "Multiplexing Seven Segment Display",
    "section": "FPGA Design",
    "text": "FPGA Design\nThe FPGA design for this lab was constructed in a modular and hierarchical method to meet teh multiplexed display instructions. The top level module lab2_bb coordinated the system while sevenseg provided the specific functionality.\n\n\n\n\n\n\n\n\nSignal Name\nType\nDetails\n\n\n\n\n[3:0] s0, s1\ninput\nDIP switches\n\n\n[4:0] led\noutput\nLEDs (the sum of s0 and s1)\n\n\n[6:0] seg\noutput\ncommon anode outputs on 7-segment display\n\n\ndisp0, disp1\ninternal\nthe “enable” on the mux taking in s0 and s1 as inputs\n\n\n\nThere is a top level module lab2_bb that instaniates the iCE40 oscillator and uses lab2_bbtb to verify simulation. The modules divides frequency using a 25-bit counter and have it “drive high” at the 19th bit (or when counter ==(2.^19)). This toggles a select signal select_mux to switch between the two hexadecimal inputs. Then it assigns the sum out (assign led = s0 + s1). Then control the digit enable signals disp0 and disp1 to ensure one display is high at a time. The sevenseg module is reused from Lab 1 and is a pure combinational decoder.\n\nTechnical Documentation\nThe source code for the project can be found in the associated GitHub repository.\n\n\nBlock Diagram\n\nFigure 1: Block diagram of the Verilog design.\nThe block diagram in Figure 2 demonstrates the overall architecture of the design. The top-level module lab2_bb includes one other module: the seven segment decoder while all the other outputs are internal.\n\n\nSchematic\n\nFigure 2: Schematic of the physical circuit of the FPGA, LEDs, switches and the 7-segment display.\n\nFigure 3: Shows the calculations of the resistors from Figure 3. A explanation below why each resistor was intentionally used:\n(1) PNP transistor: The transistor drives a lot of current and ensure that the FPGA pins were not sinking more than 8mA (our safety margin was 4mA). So thefore the base emitter saturation voltage (VBE(sat) = 0.7V). Taken into account then our resistor value is 650Ω.\n(2) Green LEDs: The forward voltage of a green LED is typically ~2V and we want current to be reasonably low at ~5mA and still be somewhat. Our resistor value is 260Ω.\n(3) 7-Segment: The PNP transistor also contains a collector emitter saturation voltage (VCE(sat) of 0.2V. The transistor drives a lot of current and ensure that the FPGA pins were not sinking more than 8mA (the safety margin used was 1mA). Then take into account the red LED forward voltage (~1.8V). Therefore the resistor value is 1.3kΩ."
  },
  {
    "objectID": "Lab_2.html#results-and-discussion",
    "href": "Lab_2.html#results-and-discussion",
    "title": "Multiplexing Seven Segment Display",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nThe QuestaSim confirmed the correct operation across all 256 input combinations and expected values. disp0 and disp1 toggled correctly in the end. This proved to the more diffciult protion of the lab was debugging and following the modular flow of how and what was affecting disp0 and disp1. The segment encodings matched the expected hexadecimal vlaues as well as the LED sum ([4:0]led) mathced the mathematical sum in all cases. The dual seven segment provided a clean display with no signs of ghosting. Some limitations and improvements could be adding a programable counter division could help with flexibility because the multiplexing frequency was fixed.\n\nTestbench Simulation\n Figure 4: Screenshot of a QuestaSim simulation that the sevenseg module works with inputs [3:0]s and outputs [6:0]seg so we can also affirm and validate to move on to the top module lab2_bb for test simulation.\n Figure 5a: Screenshot of a QuestaSim simulation demonstrating that all 256 tests succesfully work for the singel seven segment decoder module. We also see the select line: select_mux toggles and switches, therefore triggering disp0 and disp1 correctly.\n Figure 5b: Screenshot of QuestaSim waveforms that show a simulation that executed a run time of 0.5 seconds instead of 50000 ns to see the toggle on the select line: select_mux. This initiates disp0 and disp1 to switch from LOW to HIGH and vice versa."
  },
  {
    "objectID": "Lab_2.html#conclusion",
    "href": "Lab_2.html#conclusion",
    "title": "Multiplexing Seven Segment Display",
    "section": "Conclusion",
    "text": "Conclusion\nIn this lab, I successfully designed and implemented a time-multiplexed dual seven-segment display system on the FPGA. By dividing down the high-speed oscillator, I generated a stable clock that alternately enabled the two display digits while sharing a single segment decoder. The system correctly displayed two independent hexadecimal values and their binary sum on external LEDs. Both simulation and hardware testing confirmed the correctness of the design.\nLab 2 emphasized the importance of time multiplexing as a resource-sharing strategy. I learned how to coordinate hardware timing so that multiple devices could be driven with limited FPGA resources. Debugging in QuestaSim revealed subtle issues, such as uninitialized signals and reset polarity mismatches, which highlighted the difference between simulation behavior and physical FPGA behavior. If given more time, I would experiment with brightness control through pulse-width modulation (PWM) to explore display dimming. I spent a total of 25 hours working on this lab."
  },
  {
    "objectID": "Lab_2.html#ai-prototype-summary",
    "href": "Lab_2.html#ai-prototype-summary",
    "title": "Multiplexing Seven Segment Display",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nThe LLM I used to generate SystemVerilog was Copilot. The quality of the LLM-generated SystemVerilog code was surprisingly high. The initial response included a clean and modular design with a separate decoder module and a top-level multiplexing module. The use of always_comb and always_ff blocks was appropriate and aligned with best practices for synthesizable code. The logic for toggling between inputs using a simple clock divider was intuitive and easy to follow. I’d rate the output high, mainly because it was correct, sound, and modular, and this is ideal for synthesis and simulation.\nOne interesting aspect was the use of logic instead of reg or wire, which is more idiomatic in SystemVerilog but less common in older Verilog codebases. The always_comb block was also a nice touch because it ensures combinational behavior without the risk of unintended latches. Additionally, the use of a separate decoder module made the design more reusable and testable, which is something I hadn’t considered in my initial approach. The design was synthesized successfully and behaved correctly in simulation.\nIf I were able to redo Lab 2 and implement an LLM in my HDL workflow, I would: - Start with a simulation-first mindset: Even if the code looks correct, simulating it early helps catch subtle issues like latch inference or multiple drivers. - Use the LLM for testbench generation: It’s great at generating stimulus and expected output logic, which speeds up verification."
  },
  {
    "objectID": "Lab_4.html",
    "href": "Lab_4.html",
    "title": "Digital Audio",
    "section": "",
    "text": "Figure 1: Shows the Microprocessor Development Board v.4 with the Upduino FPGA and MCU, along with pushbuttons and switches.\nIn this lab, I used the STM32L432KC microcontroller to play music by generating square waves through timer-controlled PWM output. The MCU’s PLL was set to a stable 80 MHz system clock, which was then routed into two timers: TIM15 and TIM16. TIM16 was used to generate the PWM output that created the pitch of each note, while TIM15 was used to generate millisecond-accurate delays that held each note for the correct duration. A GPIO pin (PA6) was set to alternate function (AF14) and then carried the PWM signal to an LM386 audio amplifier, which drove an 8 Ω speaker.\nThe lab required the system to play Für Elise using an array of frequency-duration pairs. The design also supported accurate note durations, proper rests, and maintained pitch accuracy within 1% across the 220–1000 Hz range. For excellence, I extended the design to also play the Star Wars theme, The Imperial March and added a potentiometer for volume control."
  },
  {
    "objectID": "Lab_4.html#introduction",
    "href": "Lab_4.html#introduction",
    "title": "Digital Audio",
    "section": "",
    "text": "Figure 1: Shows the Microprocessor Development Board v.4 with the Upduino FPGA and MCU, along with pushbuttons and switches.\nIn this lab, I used the STM32L432KC microcontroller to play music by generating square waves through timer-controlled PWM output. The MCU’s PLL was set to a stable 80 MHz system clock, which was then routed into two timers: TIM15 and TIM16. TIM16 was used to generate the PWM output that created the pitch of each note, while TIM15 was used to generate millisecond-accurate delays that held each note for the correct duration. A GPIO pin (PA6) was set to alternate function (AF14) and then carried the PWM signal to an LM386 audio amplifier, which drove an 8 Ω speaker.\nThe lab required the system to play Für Elise using an array of frequency-duration pairs. The design also supported accurate note durations, proper rests, and maintained pitch accuracy within 1% across the 220–1000 Hz range. For excellence, I extended the design to also play the Star Wars theme, The Imperial March and added a potentiometer for volume control."
  },
  {
    "objectID": "Lab_4.html#design-and-testing-methodology",
    "href": "Lab_4.html#design-and-testing-methodology",
    "title": "Digital Audio",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nThe design began with carefully reading the STM32L432KC reference manual and datasheet to understand the required registers for the Reset and Clock Control (RCC), General-Purpose I/O (GPIO), and Timers (TIM15, TIM16).\nClock Setup: The system clock was configured via PLL to 80 MHz while the flash latency was set to 4 wait states to support this speed. RCC was enabled for GPIOA, TIM15, and TIM16.\nGPIO Configuration: Pin PA6 was configured as alternate function mode (AF14) to output TIM16_CH1 PWM.\nTimer Setup: \\[\n\\frac{f_{clk}}{(PSC+1)(ARR+1)}\n\\]\nAlthough the prescalar (PSC) and auto-reload register (ARR) appear together in this formula, they serve different roles as dividers. The PSC divides the high-speed system clock into a slower “tick” rate. The ARR then specifies how many of those ticks occur before the counter resets to 0. This separation allows flexible tuning while keeping calculations and register values within valid ranges.\nTIM16 (PWM Generator): ARR and CCR1 were calculated by: \\[\nARR = \\frac{f_{clk}}{f_{out}} - 1\n\\]\nTIM15 (Duration Timer) was used for delays. Here, the PSC was set to PSC = 79, so the timer ticked at 1 MHz (1 µs per tick): \\[\nf_{\\text{tick}} = \\frac{80{,}000{,}000\\ \\text{Hz}}{79+1} = 1{,}000{,}000 \\ \\text{Hz}\n\\]\n\nTechnical Documentation\nThe source code for the project can be found in the associated GitHub repository."
  },
  {
    "objectID": "Lab_4.html#schematic",
    "href": "Lab_4.html#schematic",
    "title": "Digital Audio",
    "section": "Schematic",
    "text": "Schematic\n\nFigure 3: Schematic of the physical circuit of the FPGA, LEDs, switches and the 7-segment display.\nThis shows the physical layout of the design. An internal 1.5 kΩ pull-up resistor was used to ensure the active-low reset pin was not floating. The current running through the diode of the seven segment display (~1 mA) was divided by the Vcc subtracted by the forward voltage of a red LED."
  },
  {
    "objectID": "Lab_4.html#calculations-and-results",
    "href": "Lab_4.html#calculations-and-results",
    "title": "Digital Audio",
    "section": "Calculations and Results",
    "text": "Calculations and Results\nTo verify the performance of our design, we calculated the ranges of frequencies and durations supported by our timer configuration. With a system clock of 80 MHz and using a prescalar of 79, \\[\nPSC = 79 \\quad \\Rightarrow \\quad f_{\\text{tick}} = \\frac{80{,}000{,}000}{79+1} = 1{,}000{,}000 \\, \\text{Hz}\n\\] the timer increments every $1 , s$.\n\nMinimum Frequency Supported\nThe maximum auto-reload value on a 16-bit timer is \\(ARR_{\\max} = 2^{16} - 1 = 65{,}535\\) which corresponds to a minimum frequency of \\[\nf_{\\min} = \\frac{f_{\\text{tick}}}{ARR_{\\max} + 1}\n= \\frac{1{,}000{,}000\\ \\text{Hz}}{65{,}536} \\approx 15.26 \\, \\text{Hz}.\n\\] Thus, our design can reliably produce pitches as low as ~15 Hz.\n\n\nMaximum Frequency Supported\nThe smallest valid ARR value is 1, which gives: \\[\nf_{\\max} = \\frac{f_{\\text{tick}}}{ARR_{\\min} + 1}\n= \\frac{1{,}000{,}000}{2} = 500{,}000 \\, \\text{Hz} = 500\\ \\text{kHz}.\n\\] Therefore, the minimum and maximum frequencies that be played are 15 Hz and 500 kHz. This is far above the audio range, so any audible note (20 Hz – 20 kHz) should be fully captured. ### Minimum Duration Supported The timer’s resolution is one tick: \\[t_{\\min} = \\frac{1}{f_{\\text{tick}}} = 1 \\, \\mu s.\n\\] This means we can produce rests or note durations as short as one microsecond, though in practice this is limited by the speed of audible perception.\n\n\nMaximum Duration Supported\nFor long delays (rests or note holds), we use TIM15 with the same tick frequency of \\((1 \\, \\mu s)\\). The maximum delay is: \\[t_{\\max} = (ARR_{\\max} + 1) \\times \\frac{1}{f_{\\text{tick}}}\n= 65{,}536 \\times 1 \\, \\mu s \\approx 65.5 \\, \\text{ms}.\n\\]\nIf longer note durations are required, we can extend them by looping multiple timer intervals.\n\nOscilliscope Traces of Frequencies\n\nFigure 6: Screenshot of a oscilliscope waveform validating the exact frequency of 2.41 Hz.\n\n\n\nVerifying of Pitch Accuracy\nTo calculate and validate pitch accuracy across our range (220 – 1000 Hz) we can first evaulate our ARR value with the desired frequency and then move backwards and plug in a rounded down value of ARR due to the hardware imperfections: \\[ARR = \\frac{f_{\\text{tick}}}{f_{out}} - 1\n\\]\nSo therefore, starting with the lower end of the frequency range at 220 Hz, \\[\nARR = \\frac{1\\ \\text{MHz}}{220\\ \\text{Hz}} - 1 =4544.\\overline{45}\n\\]\nNow we can utilize this ARR value and say due to imperfections in hardware and/or software we can round down our ARR value to the nearest integer and then plug it in and see what our actual frequency is, \\[\n{f_\\text{des}} = \\frac{f_\\text{tick}}{ARR + 1} = \\frac{1 \\text{MHz}}{4545} = 220.022\\ \\text{Hz}\n\\]\nNow utilize both the expected and desired frequencies to calculate the percent error, \\[\n\\frac{220.022\\ \\text{Hz} - 220\\ \\text{Hz}}{220\\ \\text{Hz}} = 0.0001 = 0.01\\%\n\\]\nNow we can calculate with our higher end frequency of 1000 Hz using the same method: \\[\nARR = \\frac{1\\ \\text{MHz}}{1000\\ \\text{Hz}} - 1 = 999\n\\]\nBecuase our ARR value is an integer value, theoretically there should be no percent error due based on previous remarks of rounding down decimal values. So our percent error would be zero \\[\n{f_\\text{des}} = {f_\\text{exp}}\\quad \\Rightarrow \\quad = 0\\%\n\\]\nWith these calculations, I demonstrated the timer supports all required note frequencies and durations. The pitch accuracy is at least within \\(1\\%\\) across the target range. Rests (when frequency = 0) are correctly implemented by disabling the channel output."
  },
  {
    "objectID": "Lab_4.html#conclusion",
    "href": "Lab_4.html#conclusion",
    "title": "Digital Audio",
    "section": "Conclusion",
    "text": "Conclusion\nThis lab demonstrated how to use the STM32L432KC microcontroller to generate music through timers, PWM, and GPIO. The design successfully played Für Elise at the correct tempo and pitch accuracy, with proper rests. For extension, the design also played the Star Wars theme, and a potentiometer was added for volume control. Frequency accuracy were in range of 1%. I spent approximately 17 hours completing this lab, including datasheet reading, code debugging, and oscilloscope testing.\nWatch the demo!"
  },
  {
    "objectID": "Lab_4.html#ai-prototype-summary",
    "href": "Lab_4.html#ai-prototype-summary",
    "title": "Digital Audio",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nWhen I used ChatGPT to help me code for the STM32L432, I found the output surprisingly effective. The explanations were written in a way that pulled together both the math (timer frequency formulas) and the hardware setup steps (registers, GPIO alternate functions). In some cases, this was faster and clearer than digging through the reference manual on my own, since the manual is dense and not always organized around the specific use case I had in mind. For instance, the LLM explained the relation between PSC, ARR, and the timer input clock in one concise formula, something I would have had to piece together across multiple sections of the manual. This is once I uploaded the manual as reference.\nFor timers, it provided a full recipe with both math and register workflow. So I’d rate it more useful as a teacher than as a pure document search engine."
  }
]