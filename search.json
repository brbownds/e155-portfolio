[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Portfolio",
    "section": "",
    "text": "Hello! My name is Broderick Bownds and I am a junior engineering major with a focus of Electrical and Computer Engineering at Harvey Mudd College. I am passionate about designing efficient systems at the intersection of hardware and signal processing. My experience spans FPGA development, system-level design, CAD-based prototyping. Beyond the lab, I am committed to inclusive innovation, such as redesigning neuroimaging caps for textured hair, mentoring youth in 3D design and coding through Project Think, being involved in NSBE, and leading through the Annenberg Leadership Forum."
  },
  {
    "objectID": "e155 labs/lab 3/Lab_3.html",
    "href": "e155 labs/lab 3/Lab_3.html",
    "title": "Keypad Scanner",
    "section": "",
    "text": "Comming Soon"
  },
  {
    "objectID": "e155 labs/lab 3/Lab_3.html#introduction",
    "href": "e155 labs/lab 3/Lab_3.html#introduction",
    "title": "Keypad Scanner",
    "section": "Introduction",
    "text": "Introduction\nIn this lab, a digital circuit was implemented on the FPGA to scan a 4×4 matrix keypad and display the last two hexadecimal digits pressed on a dual seven-segment display. Each key press was registered exactly once, regardless of how long the key was held, and additional inputs were ignored while one key remained pressed. The design used a slow clock divider for debouncing, a synchronizer to handle asynchronous inputs, and a finite state machine (FSM) to control scanning and key registration. Simulations verified correct functionality before programming the FPGA for final testing."
  },
  {
    "objectID": "e155 labs/lab 3/Lab_3.html#design-and-testing-methodology",
    "href": "e155 labs/lab 3/Lab_3.html#design-and-testing-methodology",
    "title": "Keypad Scanner",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nWhen interfacing mechanical inputs with digital systems, two key challenges must be addressed: switch bouncing and metastability. Switch bouncing occurs when a button press causes rapid transitions between logic levels before settling, often leading to multiple false detections. Metastability, on the other hand, arises when asynchronous signals from user inputs do not align with the system clock, potentially causing undefined or unstable logic states. Accounting for both circumstances was essential to ensure reliable key registration and predictable circuit behavior.\nA slow clock divider reduced the 48 MHz system clock to 240 Hz, providing sufficient time between samples to eliminate switch bounce. A two-stage synchronizer stabilized asynchronous signals from the keypad to prevent metastability. The main control logic was implemented as a finite state machine (FSM) that sequentially scanned each keypad row, detected valid presses, and ensured that only one key was registered per activation. ## FPGA Design The FPGA implementation consisted of several SystemVerilog modules:\nAt the top level (lab3_bb.sv), the internal high-speed oscillator (HSOSC) provided a 24 MHz clock, which was divided down by a counter to a slow clock of approximately 240 Hz. This slower clock was used both for keypad scanning and seven-segment display multiplexing, ensuring stable visual output and eliminating flicker or “ghosting.”\nThe key modules were:\nsynchronizer.sv – Implements a two-stage flip-flop synchronizer to align asynchronous keypad inputs, rows and columns to row_sync and col_sync the system clock, preventing metastability.\nkeyscan.sv – A FSM that cycles through each keypad row, waits for settling, detects single key presses (active high press), and generates one-shot enable signals. It also locks out additional inputs while a key is held.\ndebounce.sv – Uses a counter-based filter to ensure that a signal must remain stable for multiple clock cycles before being accepted as valid, removing the effects of switch bounce.\nkeydecoder.sv – Converts the synchronized row and column pair into the corresponding hexadecimal digit.\nsevenseg.sv – Drives the dual seven-segment display using time multiplexing; the most recent digit is displayed on the right.\n\nTechnical Documentation\nThe source code for the project can be found in the associated GitHub repository.\n\n\nBlock Diagram\n\n\n\nFigure 1: System-level block diagram illustrating data flow between the oscillator, synchronizer, FSM, decoder, and display modules.\n\n\n\n\nSchematic\n\n\n\nFigure 2: Schematic of the physical circuit of the FPGA, LEDs, switches and the 7-segment display.\n\n\n\n\nTestbench Simulations\nEach major SystemVerilog module was verified through an individual testbench in QuestaSim to confirm correct functionality before integration. These simulations validated signal timing, state transitions, and inter-module communication, ensuring that each component operated as intended. This modular testing approach demonstrated the design’s robustness and reusability—allowing issues to be isolated and resolved early before full system synthesis on the FPGA.\n\n\n\nFigure 3a: QuestaSim simulation that the lab3_bb.svoverall functions properly\n\n\n\n\n\nFigure 3b: QuestaSim simulation that the synchronizer.svoverall functions properly\n\n\n\n\n\nFigure 3c: QuestaSim simulation that the keyscan.svoverall functions properly\n\n\n\n\n\nFigure 3d: QuestaSim simulation that the debounce.svoverall functions properly\n\n\n\n\n\nFigure 3e: QuestaSim simulation that the keydecoder.svoverall functions properly"
  },
  {
    "objectID": "e155 labs/lab 3/Lab_3.html#conclusion",
    "href": "e155 labs/lab 3/Lab_3.html#conclusion",
    "title": "Keypad Scanner",
    "section": "Conclusion",
    "text": "Conclusion"
  },
  {
    "objectID": "e155 labs/lab 3/Lab_3.html#ai-prototype-summary",
    "href": "e155 labs/lab 3/Lab_3.html#ai-prototype-summary",
    "title": "Keypad Scanner",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary"
  },
  {
    "objectID": "e155 labs/lab 5/Lab_5.html",
    "href": "e155 labs/lab 5/Lab_5.html",
    "title": "Interrupts",
    "section": "",
    "text": "In this lab, the STM32L432KC microcontroller was used to measure the angular speed and direction of a DC motor by interfacing with a quadrature encoder through hardware interrupts. A quadature encoder is a rotary encoder that produces two-square wave outputs (usually Channel A and Channel B) which are 90° out of phase with each other. Two 5 V-tolerant pins (PA6 and PA8) captured the encoder’s 90° out-of-phase signals, and the MCU was configured to trigger interrupts on both rising and falling edges to achieve full resolution. Each interrupt updated a counter that was used to calculate motor speed in revolutions per second (rev/s) and determine rotational direction, which were displayed on the Segger Studio terminal at a rate of 1Hz. A timer TIM2 provided consistent 1 Hz updates for velocity calculation and display."
  },
  {
    "objectID": "e155 labs/lab 5/Lab_5.html#introduction",
    "href": "e155 labs/lab 5/Lab_5.html#introduction",
    "title": "Interrupts",
    "section": "",
    "text": "In this lab, the STM32L432KC microcontroller was used to measure the angular speed and direction of a DC motor by interfacing with a quadrature encoder through hardware interrupts. A quadature encoder is a rotary encoder that produces two-square wave outputs (usually Channel A and Channel B) which are 90° out of phase with each other. Two 5 V-tolerant pins (PA6 and PA8) captured the encoder’s 90° out-of-phase signals, and the MCU was configured to trigger interrupts on both rising and falling edges to achieve full resolution. Each interrupt updated a counter that was used to calculate motor speed in revolutions per second (rev/s) and determine rotational direction, which were displayed on the Segger Studio terminal at a rate of 1Hz. A timer TIM2 provided consistent 1 Hz updates for velocity calculation and display."
  },
  {
    "objectID": "e155 labs/lab 5/Lab_5.html#design-and-testing-methodology",
    "href": "e155 labs/lab 5/Lab_5.html#design-and-testing-methodology",
    "title": "Interrupts",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nTo implement the design, ENCODER_A and ENCODER_B were connected to pins PA6 and PA8, both configured as digital inputs with internal pull-downs to ensure clean signal transitions. The external interrupt (EXTI) peripheral was set to trigger on both rising and falling edges, enabling x4 edge detection for speed and direction measurement.\nTo validate system performance, two more GPIO pins were toggled—one in the main loop (polling) (PA4) and one inside the interrupt handler (PA5). This allowed the oscilloscope comparison of their response times. In the later section, I can confirm that interrupts captured every encoder edge while polling missed several transitions, especially at higher speeds.\nOverall, this lab demonstrated how interrupts provide accurate, real-time measurement of high-speed encoder signals. The setup for calculating speed and determining roational direction is shown below.\n\nCalculating Speed\nIn calculating the velocity we can convene to the TS-25GA370 Datasheet and see that at 12V, the pulses per revolution (PPR) at 408 meaning each full turn of the motor shaft produces 408 complete sqaure-waves cycles on Channel A (and Channel B).\nEach pulse two two channels and two edges per channel (rising and falling), so there are four detectable rising and falling edges per pulse: \\[\n\\text{edges per rev} = \\text{PPR} \\times\\ 4 = 408 \\times\\ 4 = 1632\n\\]\nThe interrupt then detects on every edge of both A and B. Therefore, if the code counts all edges for one seconds, the raw counter give you edge per second. To convert into pulses per second (PPS) - divide by 4. Then to convert to revolutions per second (RPS), divide by PRR: \\[\n\\text{rev/s} = \\frac{\\text{edges per second}}{4\\times\\ 408}\n\\]\nI can take the information and calculate the velocity of the motor at 12V rated at 150 RPM, \\[\n\\text{rev/s} = \\frac{\\text{RPM}}{60\\ \\text{sec}} = \\frac{150 \\frac{rev}{min}}{60\\ \\text{sec}} = 2.5\\ \\text{rev/s}\n\\]\nTherefore, the calculated speed of the motor should about 2.5 rev/s at 12V.\n\n\nRotational Direction Logic\nAs previously stated, Channel A and Channel B are 90° out of phase. So as the motor shaft rotates, A and B take turns rising and falling. A table is shown how we determine clockwise and counter-clockwise rotation:\n\n\n\nChannel A\nChannel B\nRotation (CW)\n\n\n\n\n0\n0\nstart\n\n\n1\n0\nA rises first (CW)\n\n\n1\n1\nB rises next (CWW)\n\n\n0\n1\nA falls (CW)\n\n\n0\n0\nB falls - back to start\n\n\n\nIf motor spins clockwise A leads B and if counter-clockwise, B leads A."
  },
  {
    "objectID": "e155 labs/lab 5/Lab_5.html#technical-documentation",
    "href": "e155 labs/lab 5/Lab_5.html#technical-documentation",
    "title": "Interrupts",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for the project can be found in the associated GitHub repository.\n\nSchematic\n\n\n\nFigure 1: Schematic of the physical circuit layout of the STM32L432 MCU Board and the 25GA-370 DC Motor\n\n\n\n\nFlowchart\n\n\n\nFigure 2: Flowchart of the interrupt-driven encoder system illustrating the code"
  },
  {
    "objectID": "e155 labs/lab 5/Lab_5.html#verifying-correct-motor-speeds",
    "href": "e155 labs/lab 5/Lab_5.html#verifying-correct-motor-speeds",
    "title": "Interrupts",
    "section": "Verifying Correct Motor Speeds",
    "text": "Verifying Correct Motor Speeds\nIn verifying the DC motor speed we can take a oscilloscope trace of the measured the motor signal and check this against the calculated value from the motor’s datasheet.\n\n\n\nFigure 3: Oscilloscope trace of the DC Motor at 12V\n\n\nAs shown in Figure 3, the output period signal and can be used to back-calculate to find the measured DC motor speed: \\[\nT_{pulse} = 864.0\\ \\mu s\\quad \\Rightarrow \\quad \\frac{\\text{1 pulse}}{T_{pulse}} = 1157.40\\ \\frac{\\text{pulses}}{\\text{sec}}\n\\] \\[\n\\frac{1157.41\\ \\frac{\\text{pulses}}{\\text{sec}}}{408 \\frac{\\text{pulses}}{\\text{rev}}} = 2.837\\ \\text{rev/s}\n\\]\nFrom the calculated we can cross-reference with our actual values:\n\n\n\nFigure 4: Speed values from DC motor displayed from Segger Studio terminal from main.c code\n\n\nTherefore the speed error from the code and the measured oscilloscope is negilible. However the deviation speed from the datasheet and the measured are more significant possibly due to the motor speed itself fluctuating and not rotating at the same frequency."
  },
  {
    "objectID": "e155 labs/lab 5/Lab_5.html#polling-vs.-interrupts",
    "href": "e155 labs/lab 5/Lab_5.html#polling-vs.-interrupts",
    "title": "Interrupts",
    "section": "Polling vs. Interrupts",
    "text": "Polling vs. Interrupts\nIn this section, it is shown that interrupts outperform polling when sampling at high speeds. To begin, polling means the CPU perodically checks if an input has changed. This check rate depends on the main loop speed and its delays. For example, if an encoder pulses between checks, it’ll miss it. Interrupts are event driven because the hardware triggers the MCU instantly when a change occurs. It pauses the CPU (main loop) to service the event. In simple terms interrupts detect every edge even at high frequency.\n\n\n\nFigure 5: Oscilloscope traces of the differences in polling and interrupts and how it captures the encoder signal. Yellow = ENCODER, Blue = INTERRUPT, Pink = POLLING\n\n\nNow this can be connected to the Nyquist-Shannon sampling theorem that says to accurately reconstruct a signal, you sample at twice its maximum frequency to also avoid aliasing and folding: \\[\nf_{s} &gt; 2f_{max}\n\\] For polling, as shown in the figure, the sampling frequency equals how often the loop reads the input. We clearly we that the encoder (yellow) produces a ~2 kHz and the polling pulse (pink) runs at 110 Hz, this is clearly below the Nyquist rate and therefore aliasing the rising/falling edges. The interrupt (blue) triggers at the signal’s edges themselves so Nyquist is never violated and there is no loss of data."
  },
  {
    "objectID": "e155 labs/lab 5/Lab_5.html#conclusion",
    "href": "e155 labs/lab 5/Lab_5.html#conclusion",
    "title": "Interrupts",
    "section": "Conclusion",
    "text": "Conclusion\nIn this lab, I successfully used the STM32L432KC MCU to measure a motor’s angular velocity and direction using a quadrature encoder with hardware interrupts. By triggering on both edges of the A and B signals, the system achieved full resolution and calculated speed in rev per second. Comparing oscilloscope readings with code output confirmed that the interrupt-based approach captured every encoder edge, while polling missed transitions due to undersampling. Overall, this lab demonstrated how interrupts enable precise, real-time signal processing and reliable velocity measurement for high-speed systems. I spent approximately 19 hours completing this lab, including datasheet reading, code debugging, and oscilloscope testing.\nWatch the demo!"
  },
  {
    "objectID": "e155 labs/lab 5/Lab_5.html#ai-prototype-summary",
    "href": "e155 labs/lab 5/Lab_5.html#ai-prototype-summary",
    "title": "Interrupts",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nCopilot helped me interface a quadrature encoder with the STM32L432KC and was a not-so-surprsing surprising experience. I asked for interrupt-based decoding, and Copilot immediately suggested using EXTI lines mapped to PA0 and PA1—pins that are straightforward to configure and well-supported by the STM32. The explanation was concise but thorough, walking through both the hardware setup and the software interrupt handlers. I appreciated how it didn’t just spit out code, but explained the reasoning behind the design choices, like why rising/falling edge detection is useful and how to interpret the encoder phase relationship."
  },
  {
    "objectID": "e155 labs/lab 1/Lab_1.html",
    "href": "e155 labs/lab 1/Lab_1.html",
    "title": "FPGA Lab: High-Speed Oscillator LED Blinker",
    "section": "",
    "text": "Figure 1: Shows the Microprocessor Development Board v.4 with the Upduino FPGA and MCU, along with pushbuttons and switches.\nIn this lab, a design was implemented on the FPGA to demonstrate the functionality of the on-board high-speed oscillator by blinking one of the on-board LEDs on the development board (shown in Figure 1). The high-speed oscillator was configured at a frequency of 48 MHz and divided down using a counter to achieve a blinking frequency of 2.4 Hz."
  },
  {
    "objectID": "e155 labs/lab 1/Lab_1.html#introduction",
    "href": "e155 labs/lab 1/Lab_1.html#introduction",
    "title": "FPGA Lab: High-Speed Oscillator LED Blinker",
    "section": "",
    "text": "Figure 1: Shows the Microprocessor Development Board v.4 with the Upduino FPGA and MCU, along with pushbuttons and switches.\nIn this lab, a design was implemented on the FPGA to demonstrate the functionality of the on-board high-speed oscillator by blinking one of the on-board LEDs on the development board (shown in Figure 1). The high-speed oscillator was configured at a frequency of 48 MHz and divided down using a counter to achieve a blinking frequency of 2.4 Hz."
  },
  {
    "objectID": "e155 labs/lab 1/Lab_1.html#design-and-testing-methodology",
    "href": "e155 labs/lab 1/Lab_1.html#design-and-testing-methodology",
    "title": "FPGA Lab: High-Speed Oscillator LED Blinker",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nWe assembled the E155 development board by soldering SMT and THT components, followed by verifying voltage regulators (3.3V and 5V). Testing involved loading a pre-written FPGA design to blink LEDs and then programming the MCU to read and echo signals. Once verified, we wrote our own Verilog modules to interface DIP switches with LEDs and a 7-segment display, synthesizing the design in Lattice Radiant and simulating with Questa ModelSim. Git was used to track project source code files.\nThe on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library was used to generate a clock signal at 24 MHz. Then, a counter was used to divide the high-frequency clock signal down so that the blinking frequency could be easily visualized using one of the on-board LEDs."
  },
  {
    "objectID": "e155 labs/lab 1/Lab_1.html#fpga-design",
    "href": "e155 labs/lab 1/Lab_1.html#fpga-design",
    "title": "FPGA Lab: High-Speed Oscillator LED Blinker",
    "section": "FPGA Design",
    "text": "FPGA Design\nOn the E155 FPGA board, the inputs and outputs are organized around the switches, LEDs, and 7-segment display. The four DIP switches s[3:0] serve as user inputs, letting you select binary values that feed into the logic of the design. The three LEDs led[2:0] provide simple output indicators: led[0] and led[1] respond to combinations of the switch inputs, while led[2] blinks at a steady rate using the FPGA’s internal 48 MHz oscillator. Finally, the seven outputs seg[6:0] drive the segments of a common anode 7-segment display, which decodes the switch settings into a numeric pattern from to 0 to F.\n\n\n\nSignal Name\nType\nDetails\n\n\n\n\n[3:0] s\ninput\nDIP switches (SW6)\n\n\n[2:0] led\noutput\nLEDs (found on P42, P38, and P28)\n\n\n[6:0] seg\noutput\ncommon anode outputs on 7-segment display\n\n\n\nIn regards to the LEDs, led[2] blinks at a frequency of 2.4Hz while led[0] switches on based a XOR relationship with s[0] and s[1] and led[1] swithes on based on AND relationship with s[2] and s[3].\nHere is the following truth table:\n\n\n\n[3:0]s\n[2:0]led\n[6:0]seg\n\n\n\n\n0000\n000\n0000001\n\n\n0001\n001\n1001111\n\n\n0010\n001\n0010010\n\n\n0011\n000\n0000110\n\n\n0100\n000\n1001100\n\n\n0101\n001\n0100100\n\n\n0110\n001\n0100000\n\n\n0111\n000\n0001111\n\n\n1000\n000\n0000000\n\n\n1001\n001\n0001100\n\n\n1010\n001\n0001000\n\n\n1011\n000\n1100000\n\n\n1100\n010\n0110001\n\n\n1101\n011\n1000010\n\n\n1110\n011\n0110000\n\n\n1111\n010\n0111000\n\n\n\n\nTechnical Documentation\nThe source code for the project can be found in the associated GitHub repository.\n\n\nBlock Diagram\n\nFigure 2: Block diagram of the Verilog design.\nThe block diagram in Figure 1 demonstrates the overall architecture of the design. The top-level module lab1_bb includes two submodules: the high-speed oscillator block (HSOSC) and the 7 segement display sevenseg_dis.\n\n\nSchematic\n\nFigure 3: Schematic of the physical circuit of the FPGA, LEDs, switches and the 7-segment display.\n\nFigure 4: Show the internal wire from the FPGA to the 7-segment display.\nThis shows the physical layout of the design. An internal 1.5 kΩ pull-up resistor was used to ensure the active-low reset pin was not floating. The current running through the diode of the seven segment display (~1 mA) was divided by the Vcc subtracted by the forward voltage of a red LED."
  },
  {
    "objectID": "e155 labs/lab 1/Lab_1.html#results-and-discussion",
    "href": "e155 labs/lab 1/Lab_1.html#results-and-discussion",
    "title": "FPGA Lab: High-Speed Oscillator LED Blinker",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nThe design met all intended design objectives through our testbench simulations.\n\nTestbench Simulation\n Figure 5: Screenshot of a QuestaSim simulation demonstrating the blinking output signal.\nNote that the timescale for the clock divider was modified to divide by 4. If a more precise output frequency was desired, a more sophisticated counter could be developed. The current design only allows for the clock to be divided by powers of two. (MIGHT GET RID OF)\n\n\nOscilliscope of Blinking LED\n\nFigure 6: Screenshot of a oscilliscope waveform validating the exact frequency of 2.41 Hz."
  },
  {
    "objectID": "e155 labs/lab 1/Lab_1.html#conclusion",
    "href": "e155 labs/lab 1/Lab_1.html#conclusion",
    "title": "FPGA Lab: High-Speed Oscillator LED Blinker",
    "section": "Conclusion",
    "text": "Conclusion\nThe design successfully blinked an external LED using the on-board high-speed oscillator. I spent a total of 10+ hours working on this lab."
  },
  {
    "objectID": "e155 labs/lab 1/Lab_1.html#ai-prototype-summary",
    "href": "e155 labs/lab 1/Lab_1.html#ai-prototype-summary",
    "title": "FPGA Lab: High-Speed Oscillator LED Blinker",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nWhen conducting the AI prototype summary, the LLM I utilized was Microsoft’s Copilot. I prompted it to “Write SystemVerilog HDL to leverage the internal high-speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz, using idiomatic SystemVerilog. Copilot produced a short module that instantiated the UP5K high-speed oscillator, divided the clock with a counter, and drove an LED. The style was pretty clean for the counter. However, when I pasted it into a fresh Lattice Radiant project and hit Synthesize, Radiant failed immediately with a syntax error: Copilot had dropped a closing parenthesis in the oscillator instantiation and missed a semicolon at the end of a localparam line. After I copied Radiant’s error text back into Copilot, it regenerated the block with the missing ) and ; added. With those fixed, the synthesis was completed.\nI would rate Copilot’s output as “good scaffolding, needs verification.” It nailed the overall structure and used modern SystemVerilog constructs I like adopting. It also wrote a clear reset path for the counter. None of those were brand-new to me, but it was helpful to see them composed neatly in a minimal example. If I did this again, I would tighten my workflow in three ways:\n\nTreat the LLM as a code generator, not an authority. I’ll immediately run the output, then feed exact tool errors back to the model for focused corrections.\nAsk the LLM to “emit compile ready, tool-specific primitives” and include a checklist in the prompt. That nudge seems to reduce trivial mistakes.\nAdd a quick unit sanity check in the prompt: “Assume ~48 MHz HFOSC; show the counter width/math to reach ~2 Hz.” That forces the model to spell out the divide math, which is convenient to verify before synthesis."
  },
  {
    "objectID": "e155 labs/lab 6/Lab_6.html#introduction",
    "href": "e155 labs/lab 6/Lab_6.html#introduction",
    "title": "The Internet of Things and Serial Peripheral Interface",
    "section": "Introduction",
    "text": "Introduction\nIn this lab, an Internet of Things (IoT) device was built using the STM32L432KC microcontroller, DS1722 temperature sensor, and ESP8266 WiFi module. The system measures ambient temperature and allows users to toggle an onboard LED through a web interface. The MCU communicates with the DS1722 via SPI and the ESP8266 via UART, using custom CMSIS-based drivers. This project demonstrated SPI communication, web-based data display, and hardware-software integration in an embedded system. By verifying signal timing with a logic analyzer and serving live temperature data over WiFi, I implemented a fully functional MCU-controlled IoT sensor node."
  },
  {
    "objectID": "e155 labs/lab 6/Lab_6.html#design-and-testing-methodology",
    "href": "e155 labs/lab 6/Lab_6.html#design-and-testing-methodology",
    "title": "The Internet of Things and Serial Peripheral Interface",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nThe system was designed using custom CMSIS-based libraries for SPI, GPIO, and UART communication. The SPI library initializes the STM32L432KC’s SPI1 peripheral by configuring its clock source, baud rate, polarity, and phase (CPOL = 0, CPHA = 1), ensuring compatibility with the DS1722 sensor’s active-high chip enable behavior. A dedicated temperature sensor library was built on top of the SPI driver providing functions to set resolution (8–12 bits) and read temperature data through two’s-complement conversion.\nThe DS1722 was wired in standard 4-wire SPI mode, with SPI_CE, SPI_SCK, SPI_MISO, and SPI_MOSI connections verified on a logic analyzer. The analyzer confirmed correct clock polarity, phase, and timing between transmitted and received bytes. To validate functionality, temperature readings were observed through UART printouts at varying conditions—room temperature, finger contact, and cooling with compressed air. These tests confirmed accurate and responsive behavior across the expected range."
  },
  {
    "objectID": "e155 labs/lab 6/Lab_6.html#technical-documentation",
    "href": "e155 labs/lab 6/Lab_6.html#technical-documentation",
    "title": "The Internet of Things and Serial Peripheral Interface",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for the project can be found in the associated GitHub repository.\n\nSchematic\n\n\n\nFigure 1: Schematic of the physical circuit layout of the STM32L432 MCU Board with the DS1722 Temperature Sensor and the wi-fi module ESP 8266"
  },
  {
    "objectID": "e155 labs/lab 6/Lab_6.html#verifiying-results",
    "href": "e155 labs/lab 6/Lab_6.html#verifiying-results",
    "title": "The Internet of Things and Serial Peripheral Interface",
    "section": "Verifiying Results",
    "text": "Verifiying Results\nTo verify correct SPI operation, the oscilloscope’s logic analyzer was used to monitor SPI_CE, SPI_SCK, SPI_MOSI, and SPI_MISO during temperature reads. The captured traces confirmed proper chip enable timing, correct clock polarity and phase, and expected byte sequencing for MSB and LSB transfers.\n\n\n\nFigure 2: Logic analyzer capture showing the SPI communication between the MCU and the DS1722 temperature sensor. The byte = 0xE0 indicates that the sensor was at 8-bit resolution.\n\n\n\n\n\nFigure 3: Logic analyzer capture showing the communication between the MCU and the DS1722 sensor at 12-bit resolution. config = 0xEE shows that the sensor was set to its highest resolution.\n\n\nThe DS1722’s output was further validated by simulating temperatures from –10 °C to 30 °C in 10 °C increments while testing all resolutions from 8-bit to 12-bit. As the resolution increased, fractional precision improved, and the measured values closely matched the expected two’s-complement temperature codes from the datasheet.\n\n\n\nFigure 4: Screenshots of the website page at different points in time to take the range of temperatures varying bit resolution."
  },
  {
    "objectID": "e155 labs/lab 6/Lab_6.html#conclusion",
    "href": "e155 labs/lab 6/Lab_6.html#conclusion",
    "title": "The Internet of Things and Serial Peripheral Interface",
    "section": "Conclusion",
    "text": "Conclusion\nThis lab demonstrated successful SPI communication between the STM32L432KC microcontroller and the DS1722 digital temperature sensor. The sensor’s configuration and data transfer were verified using both serial output and logic analyzer traces, confirming correct clock timing, chip-enable behavior, and data alignment. Temperature readings were accurate across a range from –10 °C to 30 °C, with increasing precision observed from 8-bit to 12-bit resolution. Although UART communication with the ESP8266 proved unreliable, the MCU implementation met the key objectives of SPI functionality, temperature measurement, and data formatting for IoT applications. I spent 31 hours on this lab."
  },
  {
    "objectID": "e155 labs/lab 6/Lab_6.html#ai-prototype-summary",
    "href": "e155 labs/lab 6/Lab_6.html#ai-prototype-summary",
    "title": "The Internet of Things and Serial Peripheral Interface",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nI used Microsoft’s CoPilot to help design both my web interface for displaying temperature data and the firmware function that retrieves that data from the DS1722 sensor over SPI on the STM32L432KC. The LLM produced functional, readable code that matched my setup, and its explanations helped me verify my own reasoning—particularly in the areas of SPI timing, CMSIS register usage, and manual chip-select control. I would rate the quality of the output as high The generated HTML dashboard was immediately usable: it was responsive, clean, and well-commented.\nThe C code for the SPI transaction was also well-structured—it adhered to CMSIS conventions. However, the one area I had to modify was peripheral initialization: the function assumed SPI1 was already configured, so I had to add setup code for the GPIO and SPI mode. Overall the LLM did better than mediocre which is not unusual."
  },
  {
    "objectID": "e155 labs/lab 2/Lab_2.html#introduction",
    "href": "e155 labs/lab 2/Lab_2.html#introduction",
    "title": "Multiplexing Seven Segment Display",
    "section": "Introduction",
    "text": "Introduction\nIn this lab, a time-multiplexed display system was implemented using an FPGA Upduino Board to drive a dual seven-segment display with a single decoder module. The system displayed two independent hexadecimal values sourced from two DIP switches and showed their sum on five LEDs. The design utilized transistor-based current control such as PNP transistors to safely drive the common anodes of the displays, ensuring proper brightness and avoiding bleeding or ghosting."
  },
  {
    "objectID": "e155 labs/lab 2/Lab_2.html#design-and-testing-methodology",
    "href": "e155 labs/lab 2/Lab_2.html#design-and-testing-methodology",
    "title": "Multiplexing Seven Segment Display",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nThe design included the iCE FPGA’s high-speed osciallator (HSOSC) divided down by a counter to slow down the multiplexing clock. The slow clock toggles between enabling the left or right digit by activating its common anode transistor whiel routing the correspodnign 4-bit input (s0 or s1) into the seven segment decoder. If too fast or slow then there would be flickering or the two numbers would bleed together so we had the switching at 240Hz. Humans can perceive refresh rate at 60Hz so we can speed up the frequency by a factor of 4 it won’t look like the two displays are switching.\nThe outputs of the DIP swithes provided the two hexadecimal values (s0 and s1). These values are added and the (max number is 30, 5-bit wide) was displayed on five external LEDs. The seven segment require additonal transistor circuitry to handle the higher current of the common anode pins, since a FPGA pin cannot source the needed current (~8mA)."
  },
  {
    "objectID": "e155 labs/lab 2/Lab_2.html#fpga-design",
    "href": "e155 labs/lab 2/Lab_2.html#fpga-design",
    "title": "Multiplexing Seven Segment Display",
    "section": "FPGA Design",
    "text": "FPGA Design\nThe FPGA design for this lab was constructed in a modular and hierarchical method to meet teh multiplexed display instructions. The top level module lab2_bb coordinated the system while sevenseg provided the specific functionality.\n\n\n\n\n\n\n\n\nSignal Name\nType\nDetails\n\n\n\n\n[3:0] s0, s1\ninput\nDIP switches\n\n\n[4:0] led\noutput\nLEDs (the sum of s0 and s1)\n\n\n[6:0] seg\noutput\ncommon anode outputs on 7-segment display\n\n\ndisp0, disp1\ninternal\nthe “enable” on the mux taking in s0 and s1 as inputs\n\n\n\nThere is a top level module lab2_bb that instaniates the iCE40 oscillator and uses lab2_bbtb to verify simulation. The modules divides frequency using a 25-bit counter and have it “drive high” at the 19th bit (or when counter ==(2.^19)). This toggles a select signal select_mux to switch between the two hexadecimal inputs. Then it assigns the sum out (assign led = s0 + s1). Then control the digit enable signals disp0 and disp1 to ensure one display is high at a time. The sevenseg module is reused from Lab 1 and is a pure combinational decoder.\n\nTechnical Documentation\nThe source code for the project can be found in the associated GitHub repository.\n\n\nBlock Diagram\n\nFigure 1: Block diagram of the Verilog design.\nThe block diagram in Figure 2 demonstrates the overall architecture of the design. The top-level module lab2_bb includes one other module: the seven segment decoder while all the other outputs are internal.\n\n\nSchematic\n\nFigure 2: Schematic of the physical circuit of the FPGA, LEDs, switches and the 7-segment display.\n\nFigure 3: Shows the calculations of the resistors from Figure 3. A explanation below why each resistor was intentionally used:\n(1) PNP transistor: The transistor drives a lot of current and ensure that the FPGA pins were not sinking more than 8mA (our safety margin was 4mA). So thefore the base emitter saturation voltage (VBE(sat) = 0.7V). Taken into account then our resistor value is 650Ω.\n(2) Green LEDs: The forward voltage of a green LED is typically ~2V and we want current to be reasonably low at ~5mA and still be somewhat. Our resistor value is 260Ω.\n(3) 7-Segment: The PNP transistor also contains a collector emitter saturation voltage (VCE(sat) of 0.2V. The transistor drives a lot of current and ensure that the FPGA pins were not sinking more than 8mA (the safety margin used was 1mA). Then take into account the red LED forward voltage (~1.8V). Therefore the resistor value is 1.3kΩ."
  },
  {
    "objectID": "e155 labs/lab 2/Lab_2.html#results-and-discussion",
    "href": "e155 labs/lab 2/Lab_2.html#results-and-discussion",
    "title": "Multiplexing Seven Segment Display",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nThe QuestaSim confirmed the correct operation across all 256 input combinations and expected values. disp0 and disp1 toggled correctly in the end. This proved to the more diffciult protion of the lab was debugging and following the modular flow of how and what was affecting disp0 and disp1. The segment encodings matched the expected hexadecimal vlaues as well as the LED sum ([4:0]led) mathced the mathematical sum in all cases. The dual seven segment provided a clean display with no signs of ghosting. Some limitations and improvements could be adding a programable counter division could help with flexibility because the multiplexing frequency was fixed.\n\nTestbench Simulation\n Figure 4: Screenshot of a QuestaSim simulation that the sevenseg module works with inputs [3:0]s and outputs [6:0]seg so we can also affirm and validate to move on to the top module lab2_bb for test simulation.\n Figure 5a: Screenshot of a QuestaSim simulation demonstrating that all 256 tests succesfully work for the singel seven segment decoder module. We also see the select line: select_mux toggles and switches, therefore triggering disp0 and disp1 correctly.\n Figure 5b: Screenshot of QuestaSim waveforms that show a simulation that executed a run time of 0.5 seconds instead of 50000 ns to see the toggle on the select line: select_mux. This initiates disp0 and disp1 to switch from LOW to HIGH and vice versa."
  },
  {
    "objectID": "e155 labs/lab 2/Lab_2.html#conclusion",
    "href": "e155 labs/lab 2/Lab_2.html#conclusion",
    "title": "Multiplexing Seven Segment Display",
    "section": "Conclusion",
    "text": "Conclusion\nIn this lab, I successfully designed and implemented a time-multiplexed dual seven-segment display system on the FPGA. By dividing down the high-speed oscillator, I generated a stable clock that alternately enabled the two display digits while sharing a single segment decoder. The system correctly displayed two independent hexadecimal values and their binary sum on external LEDs. Both simulation and hardware testing confirmed the correctness of the design.\nLab 2 emphasized the importance of time multiplexing as a resource-sharing strategy. I learned how to coordinate hardware timing so that multiple devices could be driven with limited FPGA resources. Debugging in QuestaSim revealed subtle issues, such as uninitialized signals and reset polarity mismatches, which highlighted the difference between simulation behavior and physical FPGA behavior. If given more time, I would experiment with brightness control through pulse-width modulation (PWM) to explore display dimming. I spent a total of 25 hours working on this lab."
  },
  {
    "objectID": "e155 labs/lab 2/Lab_2.html#ai-prototype-summary",
    "href": "e155 labs/lab 2/Lab_2.html#ai-prototype-summary",
    "title": "Multiplexing Seven Segment Display",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nThe LLM I used to generate SystemVerilog was Copilot. The quality of the LLM-generated SystemVerilog code was surprisingly high. The initial response included a clean and modular design with a separate decoder module and a top-level multiplexing module. The use of always_comb and always_ff blocks was appropriate and aligned with best practices for synthesizable code. The logic for toggling between inputs using a simple clock divider was intuitive and easy to follow. I’d rate the output high, mainly because it was correct, sound, and modular, and this is ideal for synthesis and simulation.\nOne interesting aspect was the use of logic instead of reg or wire, which is more idiomatic in SystemVerilog but less common in older Verilog codebases. The always_comb block was also a nice touch because it ensures combinational behavior without the risk of unintended latches. Additionally, the use of a separate decoder module made the design more reusable and testable, which is something I hadn’t considered in my initial approach. The design was synthesized successfully and behaved correctly in simulation.\nIf I were able to redo Lab 2 and implement an LLM in my HDL workflow, I would: - Start with a simulation-first mindset: Even if the code looks correct, simulating it early helps catch subtle issues like latch inference or multiple drivers. - Use the LLM for testbench generation: It’s great at generating stimulus and expected output logic, which speeds up verification."
  },
  {
    "objectID": "e155 labs/lab 4/Lab_4.html",
    "href": "e155 labs/lab 4/Lab_4.html",
    "title": "Digital Audio",
    "section": "",
    "text": "In this lab, I used the STM32L432KC microcontroller to play music by generating square waves through timer-controlled PWM output. The MCU’s PLL was set to a stable 80 MHz system clock, which was then routed into two timers: TIM15 and TIM16. TIM16 was used to generate the PWM output that created the pitch of each note, while TIM15 was used to generate millisecond-accurate delays that held each note for the correct duration. A GPIO pin (PA6) was set to alternate function (AF14) and then carried the PWM signal to an LM386 audio amplifier, which drove an 8 Ω speaker.\nThe lab required the system to play Für Elise using an array of frequency-duration pairs. The design also supported accurate note durations, proper rests, and maintained pitch accuracy within 1% across the 220–1000 Hz range. For excellence, I extended the design to also play the Star Wars theme, The Imperial March and added a potentiometer for volume control."
  },
  {
    "objectID": "e155 labs/lab 4/Lab_4.html#introduction",
    "href": "e155 labs/lab 4/Lab_4.html#introduction",
    "title": "Digital Audio",
    "section": "",
    "text": "In this lab, I used the STM32L432KC microcontroller to play music by generating square waves through timer-controlled PWM output. The MCU’s PLL was set to a stable 80 MHz system clock, which was then routed into two timers: TIM15 and TIM16. TIM16 was used to generate the PWM output that created the pitch of each note, while TIM15 was used to generate millisecond-accurate delays that held each note for the correct duration. A GPIO pin (PA6) was set to alternate function (AF14) and then carried the PWM signal to an LM386 audio amplifier, which drove an 8 Ω speaker.\nThe lab required the system to play Für Elise using an array of frequency-duration pairs. The design also supported accurate note durations, proper rests, and maintained pitch accuracy within 1% across the 220–1000 Hz range. For excellence, I extended the design to also play the Star Wars theme, The Imperial March and added a potentiometer for volume control."
  },
  {
    "objectID": "e155 labs/lab 4/Lab_4.html#design-and-testing-methodology",
    "href": "e155 labs/lab 4/Lab_4.html#design-and-testing-methodology",
    "title": "Digital Audio",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nThe design began with carefully reading the STM32L432KC reference manual and datasheet to understand the required registers for the Reset and Clock Control (RCC), General-Purpose I/O (GPIO), and Timers (TIM15, TIM16).\nClock Setup: The system clock was configured via PLL to 80 MHz while the flash latency was set to 4 wait states to support this speed. RCC was enabled for GPIOA, TIM15, and TIM16.\nGPIO Configuration: Pin PA6 was configured as alternate function mode (AF14) to output TIM16_CH1 PWM.\nTimer Setup: \\[\n\\frac{f_{clk}}{(PSC+1)(ARR+1)}\n\\]\nAlthough the prescalar (PSC) and auto-reload register (ARR) appear together in this formula, they serve different roles as dividers. The PSC divides the high-speed system clock into a slower “tick” rate. The ARR then specifies how many of those ticks occur before the counter resets to 0. This separation allows flexible tuning while keeping calculations and register values within valid ranges.\nTIM16 (PWM Generator): ARR and CCR1 were calculated by: \\[\nARR = \\frac{f_{clk}}{f_{out}} - 1\n\\]\nTIM15 (Duration Timer) was used for delays. Here, the PSC was set to PSC = 79, so the timer ticked at 1 MHz (1 µs per tick): \\[\nf_{\\text{tick}} = \\frac{80{,}000{,}000\\ \\text{Hz}}{79+1} = 1{,}000{,}000 \\ \\text{Hz}\n\\]\n\nTechnical Documentation\nThe source code for the project can be found in the associated GitHub repository."
  },
  {
    "objectID": "e155 labs/lab 4/Lab_4.html#schematic",
    "href": "e155 labs/lab 4/Lab_4.html#schematic",
    "title": "Digital Audio",
    "section": "Schematic",
    "text": "Schematic\n\nFigure 1: Schematic of the physical circuit layout of the STM32L432 Board and the LM386N audio amplifier."
  },
  {
    "objectID": "e155 labs/lab 4/Lab_4.html#calculations-and-results",
    "href": "e155 labs/lab 4/Lab_4.html#calculations-and-results",
    "title": "Digital Audio",
    "section": "Calculations and Results",
    "text": "Calculations and Results\nTo verify the performance of our design, we calculated the ranges of frequencies and durations supported by our timer configuration. With a system clock of 80 MHz and using a prescalar of 79, \\[\nPSC = 79 \\quad \\Rightarrow \\quad f_{\\text{tick}} = \\frac{80{,}000{,}000}{79+1} = 1{,}000{,}000 \\, \\text{Hz}\n\\] the timer increments every $1 , s$.\n\nMinimum Frequency\nThe maximum auto-reload value on a 16-bit timer is \\(ARR_{\\max} = 2^{16} - 1 = 65{,}535\\) which corresponds to a minimum frequency of \\[\nf_{\\min} = \\frac{f_{\\text{tick}}}{ARR_{\\max} + 1}\n= \\frac{1{,}000{,}000\\ \\text{Hz}}{65{,}536} \\approx 15.26 \\, \\text{Hz}.\n\\] Thus, our design can reliably produce pitches as low as ~15 Hz.\n\n\nMaximum Frequency\nThe smallest valid ARR value is 1, which gives: \\[\nf_{\\max} = \\frac{f_{\\text{tick}}}{ARR_{\\min} + 1}\n= \\frac{1{,}000{,}000}{2} = 500{,}000 \\, \\text{Hz} = 500\\ \\text{kHz}.\n\\]\nTherefore, the minimum and maximum frequencies that be played are 15 Hz and 500 kHz. This is far above the audio range, so any audible note (20 Hz – 20 kHz) should be fully captured.\n\n\nMinimum Duration\nThe timer’s resolution is one tick: \\[ARR_{\\min} = {f_{\\text{tick}} \\times t_{\\min} } = 0 \\quad \\Rightarrow \\quad t_{\\min} = 0\\text{ms}.\n\\] This means we can produce rests or note durations as short as one microsecond, though in practice this is limited by the speed of audible perception.\n\n\nMaximum Duration\nFor long delays (rests or note holds), we use TIM15 with the same tick frequency. The maximum delay is when \\(ARR_{max} = 65535\\) : \\[t_{\\max} = (ARR_{\\max} + 1) \\times f_{\\text{tick}}\n= 65536 \\times 1\\ \\text{MHz} \\approx 0.0655\\ \\mu\\text{s} = 65.5 \\, \\text{ms}.\n\\]\nIf longer note durations are required, we can extend them by looping multiple timer intervals.\n\n\nOscilliscope Traces of Frequencies\n\nFigure 2: Oscilloscope capture of a note coded at 262 Hz, measured at 260 Hz. The small difference (≈ 0.76% error) is well within the ±1% accuracy requirement.\n\nFigure 3: Oscilloscope capture of a note coded at 440 Hz, measured at 438 Hz. The frequency deviation (≈ 0.45% error) also satisfies the requirement of less than 1% error.\n\nFigure 4: Oscilloscope capture of a note coded at 659 Hz, measured at 653 Hz. The difference (≈ 0.91% error) remains within the ±1% specification.\n\n\nVerifying of Pitch Accuracy\nTo calculate and validate pitch accuracy across our range (220 – 1000 Hz) we can first evaulate our ARR value with the desired frequency and then move backwards and plug in a rounded down value of ARR due to the hardware imperfections: \\[ARR = \\frac{f_{\\text{tick}}}{f_{out}} - 1\n\\]\nSo therefore, starting with the lower end of the frequency range at 220 Hz, \\[\nARR = \\frac{1\\ \\text{MHz}}{220\\ \\text{Hz}} - 1 =4544.\\overline{45}\n\\]\nNow we can utilize this ARR value and say due to imperfections in hardware and/or software we can round down our ARR value to the nearest integer and then plug it in and see what our actual frequency is, \\[\n{f_\\text{des}} = \\frac{f_\\text{tick}}{ARR + 1} = \\frac{1 \\text{MHz}}{4545} = 220.022\\ \\text{Hz}\n\\]\nNow utilize both the expected and desired frequencies to calculate the percent error, \\[\n\\frac{220.022\\ \\text{Hz} - 220\\ \\text{Hz}}{220\\ \\text{Hz}} = 0.0001 = 0.01\\%\n\\]\nNow we can calculate with our higher end frequency of 1000 Hz using the same method: \\[\nARR = \\frac{1\\ \\text{MHz}}{1000\\ \\text{Hz}} - 1 = 999\n\\]\nBecuase our ARR value is an integer value, theoretically there should be no percent error due based on previous remarks of rounding down decimal values. So our percent error would be zero \\[\n{f_\\text{des}} = {f_\\text{exp}}\\quad \\Rightarrow \\quad = 0\\%\n\\]\nWith these calculations, I demonstrated the timer supports all required note frequencies and durations. The pitch accuracy is at least within \\(1\\%\\) across the target range. Rests (when frequency = 0) are correctly implemented by disabling the channel output."
  },
  {
    "objectID": "e155 labs/lab 4/Lab_4.html#conclusion",
    "href": "e155 labs/lab 4/Lab_4.html#conclusion",
    "title": "Digital Audio",
    "section": "Conclusion",
    "text": "Conclusion\nThis lab demonstrated how to use the STM32L432KC microcontroller to generate music through timers, PWM, and GPIO. The design successfully played Für Elise at the correct tempo and pitch accuracy, with proper rests. For extension, the design also played the Star Wars theme, and a potentiometer was added for volume control. Frequency accuracy were in range of 1%. I spent approximately 17 hours completing this lab, including datasheet reading, code debugging, and oscilloscope testing.\nWatch the demo!"
  },
  {
    "objectID": "e155 labs/lab 4/Lab_4.html#ai-prototype-summary",
    "href": "e155 labs/lab 4/Lab_4.html#ai-prototype-summary",
    "title": "Digital Audio",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nWhen I used ChatGPT to help me code for the STM32L432, I found the output surprisingly effective. The explanations were written in a way that pulled together both the math (timer frequency formulas) and the hardware setup steps (registers, GPIO alternate functions). In some cases, this was faster and clearer than digging through the reference manual on my own, since the manual is dense and not always organized around the specific use case I had in mind. For instance, the LLM explained the relation between PSC, ARR, and the timer input clock in one concise formula, something I would have had to piece together across multiple sections of the manual. This is once I uploaded the manual as reference.\nFor timers, it provided a full recipe with both math and register workflow. So I’d rate it more useful as a teacher than as a pure document search engine."
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "E155 Resources",
    "section": "",
    "text": "link to the course website here"
  }
]